#' Draw contour for EEM data using ggplot2
#' 
#' This function draw contour for EEM data using ggplot2. Use `ggsave` to save the contours.
#' 
#' @param textsize (optional) text size
#' @param geom (optional) object to display data. Can be "polygon" or "path" but default to "path" at the moment to 
#' due to some bugs for "polygon". 
#' @param x a list of EEM data generated by \code{\link[EEM]{readEEM}} function or 
#' EEMweight object generated by \code{\link[EEM]{extract}}-related functions.
#' @param n sample number. The number should not exceed \code{length(EEM)}
#' @param ncomp number of components
#' @param exlab (optional) excitation-axis label
#' @param emlab (optional) emission-axis label
#' @param color.palette (optional) contour color palette. See \code{\link[grDevices]{palette}} for more details
#' @param nlevels (optional) number of levels used to separate range of intensity value
#' @param main (optional) plot title
#' @param flipaxis (optional) flip axis
#' 
#' @return A figure is returned on the graphic device
#' 
#' @details \code{\link{drawEEM}} is faster and should be used. But since it lacks multiple plotting capacity, \code{\link{drawEEMgg}} was created to work with drawMultipleEEM.
#' 
#' @examples
#' \dontrun{
#' require(EEM)
#' data(applejuice)
#' drawEEMgg(applejuice, 1) # draw EEM of sample no.1
#' drawEEMgg(applejuice, 1, color.palette = cm.colors) # draw EEM of sample no.31 with different color
#' drawEEMgg(applejuice, 1, nlevels = 5) # reduce nlevels
#' 
#' # can be combined with other ggplot2 commands
#' drawEEMgg(applejuice, 1) + theme_bw() 
#' }
#' 
#' @seealso
#' \code{\link{drawEEM}},\code{\link{drawMultipleEEM}}
#' 
#'
#' @import ggplot2
#' @importFrom colorRamps matlab.like
#' @importFrom reshape2 melt 
#' 
#' @export
#' 
drawEEMgg <- function(x, ...) UseMethod("drawEEMgg", x)

#' @describeIn drawEEMgg draw EEM of EEM data created by \code{\link{readEEM}} function
#' 
#' @export
#'
drawEEMgg.EEM <-
  function(x, n, textsize = 25, color.palette = matlab.like, geom = "path", 
           nlevels = 20, exlab = "Excitation wavelength [nm]", emlab = "Emission wavelength [nm]", main = NULL,
           has_legend = TRUE, zlim = NULL, breaks = waiver(), flipaxis = FALSE){

    # retrieve data 
    data <- x[[n]] # data is a matrix 
    
    # if main is not provided, call it  
    if (is.null(main)) main <- names(x)[n]
    
    # melt data 
    data.melted <- melt(data)
    names(data.melted) <- c("em", "ex", "value")
        
    # plot melted data
    drawEEMgg_internal(x = data.melted, n = n, textsize = textsize, 
                      color.palette = color.palette, geom = geom, 
                      nlevels = nlevels, exlab = exlab, emlab = emlab, 
                      main = main, has_legend = has_legend, zlim = zlim, breaks = breaks,
                      flipaxis = flipaxis)
  }

#' @describeIn drawEEMgg draw contours of the output from \code{\link[EEM]{getLoading}} and 
#' \code{\link[EEM]{getReg}}. 
#' @export
drawEEMgg.EEMweight <-
    function(x, ncomp, textsize = 25, color.palette = matlab.like, geom = "path", 
             nlevels = 20, exlab = "Excitation wavelength [nm]", emlab = "Emission wavelength [nm]", main = NULL,
             has_legend = TRUE, zlim = NULL, breaks = waiver(), flipaxis = FALSE){
        
        # check inputs such that ncomp cannot exceed totalcomp
        totalcomp <- dim(x$value)[2]
        if (ncomp > totalcomp) stop("ncomp cannot exceed totalcomp.")
        
        # extract data from x
        data <- x$value[,ncomp]
        id <- names(data)
        
        # extract ex and em information from colnames
        if (isTRUE(grepl("^EX...EM...", id[1]))){
            ex <- substring(id, 3, 5)
            em <- substring(id, 8, 10)
        } else if (isTRUE(grepl("EX...EM...", id[1]))){
            pattern <- "EX...EM..."
            m <- regexpr(pattern, id)
            id <- regmatches(id, m)
            ex <- substring(id, 3, 5)
            em <- substring(id, 8, 10)
        } else {
            stop("Input did not follow the format.")
        }
        
        # melt data
        data.melted <- data.frame(em = as.numeric(em), ex = as.numeric(ex), 
                                  value = data, row.names = NULL)
        
        # main
        if (is.null(main)) {
            main <- x$title #if title is not provided, call it
            main <- paste(main, " (", ncomp, " LV)", sep = "")
            if (ncomp > 1) main <- sub("LV", "LVs", main)
        } 
        
        # plot melted data
        drawEEMgg_internal(x = data.melted, n = n, textsize = textsize, 
                           color.palette = color.palette, geom = geom, 
                           nlevels = nlevels, exlab = exlab, emlab = emlab, 
                           main = main, has_legend = has_legend, zlim = zlim,
                           breaks = breaks, flipaxis = flipaxis)
    }

#' @export
drawEEMgg_internal <-
    function(x, n = n, textsize = textsize, 
             color.palette = color.palette, geom = geom, 
             nlevels = nlevels, exlab = exlab, emlab = emlab, 
             main = main, has_legend = has_legend, zlim = zlim, breaks = breaks, flipaxis = flipaxis){
        
        # get ranges
        ex.range <- range(x$ex, na.rm = TRUE)
        em.range <- range(x$em, na.rm = TRUE)
        if (is.null(zlim)) zlim <- range(x$value, na.rm = TRUE)
        
        if (geom == "path"){
            
            v <- ggplot(x, aes(x = ex, y = em, z = value)) + 
                stat_contour(geom = "path", aes(colour = ..level..), bins = nlevels) +
                scale_colour_gradientn(colours = color.palette(nlevels), limits = c(zlim[1], zlim[2]), breaks = breaks) +
                coord_cartesian(xlim = c(ex.range[1],ex.range[2]),
                                ylim = c(em.range[1],em.range[2])) 
        }
        
        # add some themes to the plot
        w <- v +           
            theme(panel.grid = element_blank(),  # delete grid lines 
                  text = element_text(size = textsize),  # change all text size
                  panel.background = element_rect(fill = 'white'),  # white bg
                  panel.border = element_rect(colour = "grey50", fill = NA)) +
            xlab(exlab) +
            ylab(emlab) +
            ggtitle(main) + 
            theme(legend.title = element_blank(),
                  panel.border = element_rect(colour = "black"),
                  axis.text = element_text(colour = "black"),
                  axis.ticks = element_line(colour = "black"),
                  axis.title.x = element_text(vjust = -0.1),
                  axis.title.y = element_text(vjust = 1)) 
        
        if (!has_legend) w <- w + guides(color = "none") 
        if (flipaxis) w <- w + coord_flip() 
        
        return(w)
    }